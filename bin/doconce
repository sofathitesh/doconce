#!/usr/bin/env python
import os, sys, shutil, re, glob
from commands import getstatusoutput

def format():
    """
    Run the doconce module on a file (with extension .do.txt) in Doconce format
    and produce another format (LaTeX, HTML, plain text, reStructuredText, ...).

    doconce2format HTML mydoc.do.txt
    """

    try:
        import doconce
    except ImportError:
        # use local doconce module in the doconce package source:
        try:
            thisdir = os.path.dirname(sys.argv[0])
            doconce_lib = os.path.join(thisdir, os.pardir, 'lib', 'doconce')
            sys.path.insert(0, doconce_lib)
            import doconce
            print 'Successfull import of doconce locally'
        except ImportError, e:
            print e
            print 'Could not import doconce from directory\n', os.getcwd()
            sys.exit(1)

    doconce.main()

# ----------------------- functions for insertdocstr -----------------------

def insertdocstr():
    """
    This scripts first finds all .do.txt (Doconce source code) files in a
    directory tree and transforms these to a format given as command-line
    argument to the present script. The transformed file has the extension
    .dst.txt (dst for Doc STring), regardless of the format.

    In the next phase, all .p.py files (Python files that need preprocessing)
    are visited, and for each file the C-like preprocessor (preprocess.py)
    is run on the file to include .dst.txt files into doc strings.
    The result is an ordinary .py file.

    Example:
    A file basename.p.py has a module doc string which looks like
    '''
    # #include "docstrings/doc1.dst.txt"
    '''

    In the subdirectory docstrings we have the file doc1.do.txt, which
    contains the documentation in Doconce format. The current script
    detects this file, transforms it to be desired format, say Epytext.
    That action results in doc1.epytext. This file is then renamed to
    doc1.dst.txt.

    In the next step, files of the form basename.p.py is visisted, the
    preprocess program is run, and the docstrings/doc1.dst.txt file is
    inserted in the doc string. One can run with Epytext format, which is
    suitable for running Epydoc on the files afterwards, then run with
    Sphinx, and finally re-run with "plain" format such that only quite
    raw plain text appears in the final basename.py file (this is suitable
    for Pydoc, for instance).

    Usage: doconce insertdocstr format root [preprocessor options]
    """

    try:
        format = sys.argv[1]
        root = sys.argv[2]
    except:
        print 'Usage: doconce insertdocstr format root [preprocessor options]'
        sys.exit(1)

    global doconce_program
    if os.path.isfile(os.path.join('bin', 'doconce')):
        doconce_program = os.path.join(os.getcwd(), 'bin', 'doconce')
    else:
        doconce_program = 'doconce'  # must be found somewhere in PATH
    # alternative: use sys.argv[3] argument to tell where to find doconce
    # can then run "bin/doconce insertdocstr bin" from setup.py

    print '\n----- doconce insertdocstr %s %s\nFind and transform doconce files (.do.txt) ...' % (format, root)
    arg = format
    os.path.walk(root, _walker_doconce, arg)

    print 'Find and preprocess .p.py files (insert doc strings etc.)...'
    arg = ' '.join(sys.argv[3:])  # options for preprocessor
    os.path.walk(root, _walker_include, arg)
    print '----- end of doconce insertdocstr -----\n'



# not used:
def _preprocess_all_files(rootdir, options=''):
    """
    Run preprocess on all files of the form basename.p.ext
    in the directory with root rootdir. The output of each
    preprocess run is directed to basename.ext.
    """
    def _treat_a_dir(arg, d, files):
        for f in files:
            path = os.path.join(d, f)
            if '.p.' in f and not '.svn' in f:
                basename_dotp, ext = os.path.splitext(f)
                basename, dotp = os.path.splitext(basename_dotp)
                outfilename = basename + ext
                outpath = os.path.join(d, outfilename)
                cmd = 'preprocess %s %s > %s' % (options, path, outpath)
                #print cmd
                failure = os.system(cmd)
                if failure:
                    print 'WARNING: could not run\n  %s' %  cmd

    os.path.walk(rootdir, _treat_a_dir, None)

def _run_doconce(filename_doconce, format):
    """
    Run doconce format filename_doconce.
    The result is a file with extension .dst.txt (same basename
    as filename_doconce).
    """
    if filename_doconce.startswith('__'):
        # old preprocessed file from aborted doconce execution
        print 'skipped', filename_doconce
        return

    global doconce_program # set elsewhere
    cmd = '%s format %s %s' % (doconce_program, format, filename_doconce)
    print 'run', cmd
    failure, outtext = getstatusoutput(cmd)
    if failure:
        raise OSError, 'Could not run\n%s\nin %s\n%s\n\n\n' % \
              (cmd, os.getcwd(), outtext)
    out_filename = outtext.split()[-1]
    root, ext = os.path.splitext(out_filename)
    new_filename = root + '.dst.txt'
    os.rename(out_filename, new_filename)
    print '(renamed %s to %s for possible inclusion in doc strings)\n' % (out_filename, new_filename)

def _walker_doconce(arg, dir, files):
    format = arg
    # we move to the dir:
    origdir = os.getcwd()
    os.chdir(dir)
    for f in files:
        if f[-7:] == '.do.txt':
            _run_doconce(f, format)
    os.chdir(origdir)

def _run_preprocess4includes(filename_dotp_py, options=''):
    pyfile = filename_dotp_py[:-5] + '.py'
    cmd = 'preprocess %s %s > %s' % (options, filename_dotp_py, pyfile)
    print 'run', cmd
    failure, outtext = getstatusoutput(cmd)
    #os.remove(tmp_filename)
    if failure:
        raise OSError, 'Could not run\n%s\nin %s\n%s\n\n\n' % \
              (cmd, os.getcwd(), outtext)

def _walker_include(arg, dir, files):
    options = arg
    # we move to the dir:
    origdir = os.getcwd()
    os.chdir(dir)
    for f in files:
        if f[-5:] == '.p.py':
            _run_preprocess4includes(f, options)
    os.chdir(origdir)

# ----------------------------------------------------------------------

def old2new_format():
    if len(sys.argv) == 1:
        print 'Usage: %s file1.do.txt file2.do.txt ...' % sys.argv[0]
        sys.exit(1)

    for filename in sys.argv[1:]:
        print 'Converting', filename
        _old2new(filename)

def _old2new(filename):
    """
    Read file with name filename and make substitutions of
    ___headings___ to === headings ===, etc.
    A backup of the old file is made (filename + '.old').
    """
    f = open(filename, 'r')
    lines = f.readlines()
    f.close()
    os.rename(filename, filename + '.old')

    # perform substitutions:
    nchanges = 0
    for i in range(len(lines)):
        oldline = lines[i]
        # change from ___headings___ to === headings ===:
        lines[i] = re.sub(r'(^\s*)_{7}\s*(?P<title>[^ ].*?)\s*_+\s*$',
                          r'\g<1>======= \g<title> =======' + '\n', lines[i])
        lines[i] = re.sub(r'(^\s*)_{5}\s*(?P<title>[^ ].*?)\s*_+\s*$',
                          r'\g<1>===== \g<title> =====' + '\n', lines[i])
        lines[i] = re.sub(r'(^\s*)_{3}\s*(?P<title>[^ ].*?)\s*_+\s*$',
                          r'\g<1>=== \g<title> ===' + '\n', lines[i])
        if lines[i].startswith('AUTHOR:'):
            # swith to "name at institution":
            if not ' at ' in lines[i]:
                print 'Warning, file "%s": AUTHOR line needs "name at institution" syntax' % filename

        if oldline != lines[i]:
            nchanges += 1
            print 'Changing\n  ', oldline, 'to\n  ', lines[i]

    print 'Performed %d changes in "%s"' % (nchanges, filename)
    f = open(filename, 'w')
    f.writelines(lines)
    f.close()

def LaTeX_header():
    from doconce.doconce import INTRO
    print INTRO['LaTeX']

def LaTeX_footer():
    from doconce.doconce import OUTRO
    print OUTRO['LaTeX']


def remove_inline_comments():
    try:
        filename = sys.argv[1]
    except IndexError:
        print 'Usage: doconce_remove_inline_comments.py doconcefile'
        sys.exit(1)

    shutil.copy(filename, filename + '.old~~')
    f = open(filename, 'r')
    filestr = f.read()
    f.close()
    import doconce
    filestr = doconce.doconce.subst_away_inline_comments(filestr)
    f = open(filename, 'w')
    f.write(filestr)
    f.close()
    print 'inline comments removed in', filename

def latin2html():
    """
    Substitute latin characters by their equivalent HTML encoding
    in an HTML file. See doconce.html.latin2html for more
    documentation.
    """
    from doconce.html import latin2html
    import os, shutil, sys
    for filename in sys.argv[1:]:
        if not os.path.isfile(filename):
            continue
        oldfilename = filename + '.old~'
        shutil.copy(filename, oldfilename)
        print 'transformin latin characters to HTML encoding in', filename
        f = open(oldfilename, 'r')
        try:
            text = f.read()
            newtext = latin2html(text)
            f.close()
            f = open(filename, 'w')
            f.write(newtext)
            f.close()
        except Exception, e:
            print e.__class__.__name__, ':', e,

def gwiki_figsubst():
    try:
        gwikifile = sys.argv[1]
        URLstem = sys.argv[2]
    except IndexError:
        print 'Usage: %s wikifile URL-stem' % sys.argv[0]
        print 'Ex:    %s somefile.gwiki http://code.google.com/p/myproject/trunk/doc/somedir' % sys.argv[0]
        sys.exit(1)

    # first grep out all filenames with local path:
    shutil.copy(gwikifile, gwikifile + 'old~~')
    f = open(gwikifile, 'r')
    fstr = f.read()
    f.close()

    pattern = r'\(the URL of the image file (.+?) must be inserted here\)'
    #figfiles = re.findall(pattern, fstr)
    replacement = r'%s/\g<1>' % URLstem
    fstr, n = re.subn(pattern, replacement, fstr)
    pattern = re.compile(r'<wiki:comment>\s+Put the figure file .*?</wiki:comment>', re.DOTALL)
    fstr, n2 = pattern.subn('', fstr)
    f = open(gwikifile, 'w')
    f.write(fstr)
    f.close()
    print 'Replaced %d figure references in' % n, gwikifile
    if n != n2:
        print 'Something strange: %d fig references and %g comments... Bug.' % \
              (n, n2)


def sphinx_dir():
    # If there are many files to be translatex to sphinx, there should
    # be no master file including the others. The "master file" should
    # just contain title, author, date and perhaps an intro.

    # Grab title, author, version from the command line
    title = author = None
    version = '1.0'
    theme = 'default'
    doconce_files = []
    sphinx_rootdir = 'sphinx-rootdir'
    for arg in sys.argv[1:]:
        if arg.startswith('title='):
            title = arg.split('=')[1]
        elif arg.startswith('author='):
            author = arg.split('=')[1]
        elif arg.startswith('version='):
            author = arg.split('=')[1]
        elif arg.startswith('dirname='):
            sphinx_rootdir = arg.split('=')[1]
        elif arg.startswith('theme='):
            theme = arg.split('=')[1]
        else:
            doconce_files.append(arg)

    if not doconce_files:
        print 'must have (at least one) doconce file as argument'
        print 'doconce sphinx_dir somefile.do.txt'
        sys.exit(1)
    try:
        import sphinx
    except ImportError:
        print 'Unable to import sphinx. Install sphinx from sphinx.pocoo.org.'
        print 'On Debian systems, install the \'python-sphinx\' package.'
        sys.exit(1)
    if float(sphinx.__version__[:3]) < 1.1:
        print 'Abort: sphinx version >= 1.1 required'
        sys.exit(1)


    # Make sure all files end with .do.txt
    doconce_files_basename = []
    for i in range(len(doconce_files)):
        if doconce_files[i].endswith('.do.txt'):
            pass
        else:
            doconce_files[i] += '.do.txt'
        doconce_files_basename.append(doconce_files[i][:-7])

    if title is None:
        for filename in doconce_files:
            if not os.path.isfile(filename):
                print filename, 'was not found'
                continue
            else:
                print 'searching for TITLE in', filename
            f = open(filename, 'r'); fstr = f.read(); f.close()
            if 'TITLE:' in fstr:
                for line in fstr.splitlines():
                    if line.startswith('TITLE:'):
                        title = line[6:].strip()
                        print 'Using title "%s" from' % title, filename
                        break
    if title is None:
        print '\nNo TITLE: line found in the files', ', '.join(doconce_files)
        print 'and no title="..." given on the command line'
        sys.exit(1)

    if author is None:
        import doconce
        for filename in doconce_files:
            f = open(filename, 'r'); fstr = f.read(); f.close()
            authors_and_institutions, dummy1, dummy2, dummy3 = \
                      doconce.doconce.interpret_authors(fstr, 'sphinx')
            if authors_and_institutions:
                author = [a for a, i in authors_and_institutions]

                if len(author) == 1:
                    author = author[0]
                else:
                    author = ', '.join(author[:-1] + ' and ' + author[-1])
                print 'Using author(s) "%s" from', filename
                break

    if author is None:
        print '\nNo AUTHOR: line found in the files', ', '.join(doconce_files)
        print 'and no author="..." given on the command line'
        sys.exit(1)

    print 'Title:', title
    print 'Author:', author

    f = open('tmp_sphinx_gen.sh', 'w')
    f.write("""\
#!/bin/bash
rm -rf %(sphinx_rootdir)s
echo Making %(sphinx_rootdir)s
mkdir %(sphinx_rootdir)s
sphinx-quickstart <<EOF
%(sphinx_rootdir)s
n
_
%(title)s
%(author)s
%(version)s
%(version)s
1.0
.rst
index
n
y
n
n
n
n
y
n
n
y
y
y
EOF
""" % vars())
    f.close()
    failure = os.system('sh tmp_sphinx_gen.sh')
    if failure:
        print 'Could not run script for making sphinx directory'
        sys.exit(1)
    os.chdir(sphinx_rootdir)

    # Copy themes
    import doconce.common
    install_dir = doconce.common.where()
    shutil.copy(os.path.join(install_dir, 'sphinx_themes.zip'), os.curdir)
    failure = os.system('unzip sphinx_themes.zip')
    if failure:
        print 'Could not pack out themes'
        sys.exit(1)
    os.remove('sphinx_themes.zip')
    os.rename('sphinx_themes', '_themes')
    themes = [name[8:] for name in \
              glob.glob(os.path.join('_themes', '*'))] + ['default']
    print 'These Sphinx themes were found:', themes
    f = open('conf.py', 'r');  text = f.read();  f.close()
    themes_list = ["html_theme = '%s'" % theme] + \
                  ["#html_theme = '%s'" % theme for theme in themes]
    text = text.replace("html_theme = 'default'",
                        '\n'.join(themes_list))
    text = text.replace("#html_theme_path = []",
                        "html_theme_path = ['_themes']")
    f = open('conf.py', 'w');  f.write(text);  f.close()
    f = open('make-themes.sh', 'w')
    f.write("""#!/bin/sh
# Make all themes given on the command line (or if no themes are
# given, make all themes in _themes/)

if [ $# -gt 0 ]; then
    themes=$@
else
    themes="%s"
fi

for theme in $themes; do
    doconce replace "html_theme = '%s'" "html_theme = '$theme'" conf.py
    make html
    rm -rf _build/html_$theme
    cp -r _build/html _build/html_$theme
    # set back
    doconce replace "html_theme = '$theme'" "html_theme = '%s'" conf.py
    echo "$theme is built in _build/html_$theme"
done
echo
echo "Here are the built themes:"
ls -d _build
echo "for i in _build/*; do google-chrome $i/index.html; done"

""" % (' '.join(themes), theme, theme))
    f.close()
    os.chmod('make-themes.sh', 0755)

    f = open('index.rst', 'w')
    files = '\n   '.join([filename[:-7] for filename in doconce_files])
    f.write("""
.. Master file automatically created by doconce sphinx_dir

Welcome to %(title)s!
==================================================================

Contents:

.. toctree::
   :maxdepth: 2

   %(files)s


Indices and tables
==================

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`
""" % vars())
    f.close()
    os.chdir(os.pardir)
    doconce_files_basename_list = ' '.join(doconce_files_basename)
    f = open('automake-sphinx.sh', 'w')
    f.write("""\
#!/bin/bash -x
# Autogenerated file (by doconce sphinx_dir)
# Purpose: create HTML Sphinx version of %(doconce_files_basename_list)s

# Make sure figure files/directories are placed in %(sphinx_rootdir)s
# This script copies figs/ and figures/ but no other names for figure subdirs

# Filter doconce format to sphinx format and copy to sphinx directory
files="%(doconce_files_basename_list)s"
for file in $files; do
  doconce format sphinx $file
  cp $file.rst %(sphinx_rootdir)s
done

# Copy figures
if [ -d figs ]; then
  cp -r figs %(sphinx_rootdir)s
fi
if [ -d figures ]; then
  cp -r figures %(sphinx_rootdir)s
fi

# Compile sphinx document
cd %(sphinx_rootdir)s
make clean
make html

echo
echo "firefox %(sphinx_rootdir)s/_build/html/index.html"
""" % vars())
    f.close()
    os.chmod('automake-sphinx.sh', 0755)
    print "\n'automake-sphinx.sh' contains the steps to (re)compile the sphinx version."
    print "You may want to edit this file - look at it."

# subst is taken from scitools
def usage_subst():
    print 'Usage: doconce subst [-s -m -x --restore] pattern '\
          'replacement file1 file2 file3 ...'
    print '--restore brings back the backup files'
    print '-s is the re.DOTALL or re.S modifier'
    print '-m is the re.MULTILINE or re.M modifier'
    print '-x is the re.VERBODE or re.X modifier'

def _scitools_subst(patterns, replacements, filenames,
                    pattern_matching_modifiers=0):
    """
    Replace a set of patterns by a set of replacement strings (regular
    expressions) in a series of files.
    The function essentially performs::

      for filename in filenames:
          file_string = open(filename, 'r').read()
          for pattern, replacement in zip(patterns, replacements):
              file_string = re.sub(pattern, replacement, file_string)

    A copy of the original file is taken, with extension `.old~`.
    """
    # if some arguments are strings, convert them to lists:
    if isinstance(patterns, basestring):
        patterns = [patterns]
    if isinstance(replacements, basestring):
        replacements = [replacements]
    if isinstance(filenames, basestring):
        filenames = [filenames]

    # pre-compile patterns:
    cpatterns = [re.compile(pattern, pattern_matching_modifiers) \
                 for pattern in patterns]
    modified_files = dict([(p,[]) for p in patterns])  # init
    messages = []   # for return info

    for filename in filenames:
        if not os.path.isfile(filename):
            raise IOError('%s is not a file!' % filename)
        f = open(filename, 'r');
        filestr = f.read()
        f.close()

        for pattern, cpattern, replacement in \
            zip(patterns, cpatterns, replacements):
            if cpattern.search(filestr):
                filestr = cpattern.sub(replacement, filestr)
                shutil.copy2(filename, filename + '.old~') # backup
                f = open(filename, 'w')
                f.write(filestr)
                f.close()
                modified_files[pattern].append(filename)

    # make a readable return string with substitution info:
    for pattern in sorted(modified_files):
        if modified_files[pattern]:
            replacement = replacements[patterns.index(pattern)]
            messages.append('%s replaced by %s in %s' % \
                                (pattern, replacement,
                                 ', '.join(modified_files[pattern])))

    return ', '.join(messages) if messages else 'no substitutions'

def wildcard_notation(files):
    """
    On Unix, a command-line argument like *.py is expanded
    by the shell. This is not done on Windows, where we must
    use glob.glob inside Python. This function provides a
    uniform solution.
    """
    if isinstance(files, basestring):
        files = [files]  # ensure list when single filename is given
    if sys.platform[:3] == 'win':
        import glob, operator
        filelist = [glob.glob(arg) for arg in files]
        files = reduce(operator.add, filelist)  # flatten
    return files

def subst():
    if len(sys.argv) < 3:
        usage_subst()
        sys.exit(1)

    from getopt import getopt
    optlist, args = getopt(sys.argv[1:], 'smx', 'restore')
    restore = False
    pmm = 0  # pattern matching modifiers (re.compile flags)
    for opt, value in optlist:
        if opt in ('-s',):
            if not pmm:  pmm = re.DOTALL
            else:        pmm = pmm|re.DOTALL
        if opt in ('-m',):
            if not pmm:  pmm = re.MULTILINE
            else:        pmm = pmm|re.MULTILINE
        if opt in ('-x',):
            if not pmm:  pmm = re.VERBOSE
            else:        pmm = pmm|re.VERBOSE
        if opt in ('--restore',):
            restore = True

    if restore:
        for oldfile in args:
            newfile = re.sub(r'\.old~$', '', oldfile)
            if not os.path.isfile(oldfile):
                print '%s is not a file!' % oldfile; continue
            os.rename(oldfile, newfile)
            print 'restoring %s as %s' % (oldfile,newfile)
    else:
        pattern = args[0]; replacement = args[1]
        s = _scitools_subst(pattern, replacement,
                            wildcard_notation(args[2:]), pmm)
        print s  # print info about substitutions

# replace is taken from scitools
def usage_replace():
    print 'Usage: doconce replace from-text to-text file1 file2 ...'

def replace():
    if len(sys.argv) < 3:
        usage_replace()
        sys.exit(1)

    from_text = sys.argv[1]
    to_text = sys.argv[2]
    filenames = wildcard_notation(sys.argv[3:])
    for filename in filenames:
        f = open(filename, 'r')
        text = f.read()
        f.close()
        if from_text in text:
            backup_filename = filename + '.old~~'
            shutil.copy(filename, backup_filename)
            print 'replacing %s by %s in' % (from_text, to_text), filename
            text = text.replace(from_text, to_text)
            f = open(filename, 'w')
            f.write(text)
            f.close()

def clean():
    """Remove all Doconce generated files."""
    removed = []
    doconce_files = glob.glob('*.do.txt')
    for dof in doconce_files:
        namestem = dof[:-7]
        generated_files = glob.glob(namestem + '.*')
        generated_files.remove(dof)
        files_to_keep = '.sh',
        #print 'generated_files:', namestem + '.*', generated_files
        for ext in files_to_keep:
            filename = namestem + ext
            if os.path.isfile(filename):
                generated_files.remove(filename)
        for f in generated_files:
            removed.append(f)
            os.remove(f)
    if removed:
        print 'Removed', ', '.join(removed)

def usage_guess_encoding():
    print 'Usage: doconce guess_encoding filename'

def _encoding_guesser(filename):
    """Try to guess the encoding of a file."""
    f = open(filename, 'r')
    text = f.read()
    f.close()
    encodings = ['utf-8', 'ascii', 'us-ascii', 'iso-8859-1', 'iso-8859-2',
                 'iso-8859-3', 'iso-8859-4', 'cp37', 'cp930', 'cp1047',
                 'utf-16', 'windows-1250', 'windows-1252',]
    for encoding in encodings:
        try:
            #print 'Trying encoding', encoding
            unicode(text, encoding, "strict")
        except:
            pass
        else:
            break
    return encoding

def guess_encoding():
    if len(sys.argv) != 2:
        usage_guess_encoding()
        sys.exit(1)
    filename = sys.argv[1]
    print _encoding_guesser(filename)

def usage_change_encoding():
    print 'Usage: doconce change_encoding from-encoding to-encoding file1 file2 ...'
    print 'Example: doconce change_encoding utf-8 latin-1 myfile.do.txt'

def _change_encoding_unix(filename, from_enc, to_enc):
    backupfile = filename + 'old~~'
    if sys.platform == 'linux2':
        cmd = 'iconv -f %s -t %s %s --output %s' % \
              (from_enc, to_enc, backupfile, filename)
    elif sys.platform == 'darwin':
        cmd = 'iconv -f %s -t %s %s > %s' % \
              (from_enc, to_enc, backupfile, filename)
    else:
        print 'Changing encoding is not implemented on Windows machines'
        sys.exit(1)
    os.rename(filename, backupfile)
    failure = os.system(cmd)
    if failure:
        print 'could not run', cmd
        sys.exit(1)

def _change_encoding_python(filename, from_enc, to_enc):
    f = codecs.open(filename, 'r', from_enc)
    text = f.read()
    f.close()
    f = codecs.open(filename, 'w', to_enc)
    f.write(text)
    f.close()

def change_encoding():
    if len(sys.argv) < 4:
        usage_change_encoding()
        sys.exit(1)

    from_encoding = sys.argv[1]
    to_encoding = sys.argv[2]
    filenames = wildcard_notation(sys.argv[3:])
    for filename in filenames:
        _change_encoding_unix(filename, from_encoding, to_encoding)
        # Perhaps better alternative with pure Python:
        #_change_encoding_python(filename, from_encoding, to_encoding)


def usage_bbl2rst():
    print 'Usage: doconce bbl2rst file.bbl'

def bbl2rst():
    if len(sys.argv) <= 1:
        usage_bbl2rst()
        sys.exit(1)

    bblfile = sys.argv[1]
    text = open(bblfile, 'r').read()
    pattern = r'\\bibitem\{(.+)\}' + '\n'
    text = re.sub(pattern, r'.. [\g<1>] ', text)
    text = text.replace(r'\newblock ', '')
    text = text.replace('~', ' ')
    pattern = r'\{\\em (.+?)\}'
    text = re.sub(pattern, r'*\g<1>*', text)
    text = text.replace('\\', '')
    lines = []
    for line in text.splitlines():
        line = line.strip()
        if 'thebibliography' in line:
            continue
        elif line[:2] == '..':
            lines.append(line + '\n')
        else:
            lines.append('   ' + line  + '\n')

    outfile = bblfile[:-3] + 'rst'
    f = open(outfile, 'w')
    f.writelines(lines)
    f.close()
    print 'reStructuredText bibliography in', outfile

# -----------------------------------------------------------------------

commands = 'format insertdocstr old2new_format gwiki_figsubst remove_inline_comments latin2html sphinx_dir subst replace clean help LaTeX_header LaTeX_footer guess_encoding change_encoding bbl2rst'.split()

# -----------------------------------------------------------------------

def help():
    print """
doconce format HTML|LaTeX|rst|sphinx|st|epytext|plain|gwiki|pandoc file.do.txt

doconce subst [-s -m -x --restore] regex-pattern regex-replacement file1 file2 ...
(-s is the re.DOTALL modifier, -m is the re.MULTILINE modifier,
 -x is the re.VERBOSE modifier, --restore copies backup files back again)

doconce replace from-text to-text file1 file2 ...

doconce gwiki_figsubst file.gwiki URL-of-fig-dir

doconce remove_inline_comments file.do.txt

doconce sphinx_dir file.do.txt
(requires sphinx version >= 1.1)

doconce latin2html file.html

doconce insertdocstr rootdir

doconce clean
(remove all files that the doconce format can regenerate)

doconce LaTeX_header
doconce LaTeX_footer
doconce change_encoding utf-8 latin-1 filename
doconce guess_encoding filename
doconce bbl2rst file.bbl
"""


def main():
    if len(sys.argv) == 1 or '--help' in sys.argv or '-help' in sys.argv or \
           'help' in sys.argv:
        print 'Usage: doconce command [optional arguments]'
        print 'commands: %s' % (' '.join(commands))
        help()
        sys.exit(1)

    command = sys.argv[1]
    del sys.argv[1]
    if command == '2format':
        command = 'format'

    found = False
    for registered_command in commands:
        if command == registered_command:
            found = True
            eval(command + '()')
    if not found:
        print 'command', command, 'not legal, must be among\n'
        print ', '.join(commands)

main()
